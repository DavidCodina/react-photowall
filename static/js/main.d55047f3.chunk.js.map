{"version":3,"sources":["store/reducers/photoReducer.js","store/reducers/commentReducer.js","store/reducers/index.js","store/actions/types.js","store/store.js","database/config.js","store/actions/photoActions.js","store/actions/commentActions.js","components/Photo.js","components/Photowall.js","components/Addphoto.js","components/Comments.js","components/Single.js","App.js","index.js"],"names":["initialState","photos","comments","combineReducers","photoReducer","state","action","type","filter","photo","id","payload","commentReducer","comment","middleware","thunk","store","createStore","rootReducer","compose","applyMiddleware","window","__REDUX_DEVTOOLS_EXTENSION__","firebase","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","database","loadPhotos","startLoadingPhotos","dispatch","console","log","ref","once","then","snapshot","forEach","childSnapshot","push","val","catch","error","addPhoto","startAddingPhoto","update","deletePhoto","startDeletingPhoto","remove","loadComments","startLoadingComments","key","Object","values","addComment","startAddingComment","Photo","props","className","to","src","imageLink","alt","description","onClick","history","length","Photowall","Fragment","sort","x","y","map","index","Addphoto","handleSubmit","e","preventDefault","target","elements","value","link","data","Number","Date","onSubmit","this","name","placeholder","Component","Comments","photoSpecificComments","hidden","Single","match","loading","params","find","App","setState","exact","path","render","connect","bindActionCreators","photoActions","commentActions","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.d55047f3.chunk.js","sourcesContent":["\nimport { DELETE_PHOTO, ADD_PHOTO, LOAD_PHOTOS } from \"../actions/types\";\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n//\n//  The reducer will take the state (i.e., current state) as the first argument.\n//  However, it will initially take the initial state, which we define here.\n//  The reducer is responsible for updating state.\n//\n////////////////////////////////////////////////////////////////////////////////\nconst initialState = {\n  photos: []\n};\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  In this case we are using an anonymous function.\n//  Thus when we import it into the rootReducer file (i.e., index.js in this directory),\n//  we name it when bringing it in: import photoReducer from \"./photoReducer\";\n//  However, we could name the function here: function photoReducer() { ... }\n//  Then: export default photoReducer;\n//  This is being imported into the rootReducer in the index.js file in this same directory.\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\nexport default function(state = initialState, action) {\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  //  In App.js we did this as a test:\n  //\n  //     componentDidMount(){\n  //       this.props.dispatch(deletePhoto(1));\n  //     }\n  //\n  //  Initially this will return undefined.\n  //  This is because when the reducer first gets called upon store creation we're trying\n  //  to console.log() the id of the removed action, but it's not being emitted at that time.\n  //  But then once the component mounts, the above method is called, and dispatch executes\n  //  the action creator, which then emits the action to the reducer.\n  //\n  //////////////////////////////////////////////////////////////////////////////\n  // console.log(\"photoReducer.js received the action.payload of:\");\n  // console.log(action.payload);\n  // console.log(\"\");\n\n\n  switch (action.type) {\n\n    case DELETE_PHOTO:\n      //console.log(\"case: DELETE_PHOTO\");\n      //////////////////////////////////////////////////////////////////////////////\n      //\n      //  In the tutorial he used index as the action.payload.\n      //  Thus he was able to do this:\n      //\n      //    all elements before                  , all elements after\n      //    return [...state.slice(0, action.index), ...state.slice(action.index + 1)];\n      //\n      //  However, that doesn't make a lot of sense to me.\n      //  Why is he returning an array?\n      //  And why is he using state and not state.photos?\n      //  I think it has to do with the dopey way he set it up initially.\n      //  I think some people initialize state as an array. I'm not sure why.\n      //  I wouldn't worry about it, just do this instead.\n      //\n      //////////////////////////////////////////////////////////////////////////////\n\n      return {\n        ...state,\n        photos: state.photos.filter(\n          photo => photo.id !== action.payload\n        )\n      };\n\n      case ADD_PHOTO:\n        //console.log(\"case: ADD_PHOTO\");\n        return {\n          ...state,\n          photos: [action.payload, ...state.photos]\n        };\n\n        case LOAD_PHOTOS:\n          return {\n            ...state,\n            photos: action.payload\n          };\n    default:\n      return state;\n  }\n}\n","import { ADD_COMMENT, LOAD_COMMENTS } from \"../actions/types\";\n\n\nconst initialState = {\n  comments: {}\n};\n\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case ADD_COMMENT:\n\n      //////////////////////////////////////////////////////////////////////////\n      //\n      //  Tutorial Version:\n      //\n      //  action.payload here represents { id: ..., comment: ...}\n      //  Thus the state.comments property represents an object whereby\n      //  the property names are numbers that correspond to the ids in state.photos.\n      //  Each id in state.comments contains an array of comments.\n      //\n      //////////////////////////////////////////////////////////////////////////\n\n\n      //If there is no corresponding property in comments with the current id, then return the following:\n      if ( !state.comments[action.payload.id] ){\n        return {\n          ...state,\n          //Note: [action.payload.id] is NOT an array.\n          //Rather, it's how ES6 allows us to create an object property in this context.\n          //Conversely, [action.payload.comment] IS an array.\n          comments: {\n            ...state.comments, [action.payload.id] : [action.payload.comment]\n          }\n        }\n\n      //If ther IS a corresponding property in comments with the current id, then return the following:\n      } else {\n        return {\n          ...state,\n          comments: {\n            ...state.comments, [action.payload.id] : [...state.comments[action.payload.id], action.payload.comment]\n            //Note: you want the action.payload.comment to be second. Why?\n            //Because we want it to be a comment stream, with newer comments below older comments.\n          }\n        }\n      }\n\n      //////////////////////////////////////////////////////////////////////////\n      //\n      //  My original solution (same difference):\n      //\n      //\n      //  previousComments represents all previous comments corresponding to the id.\n      //  Fore example 567 might have [\"comment 1\", \"comment 2\", ...] :\n      //\n      //    comments: {\n      //      567: [\"comment 1\", \"comment 2\", ...]\n      //    }\n      //\n      //\n      //  I was running into problems below when I tried to ...previousComments.\n      //  This was because on the first run through previousComments would be undefined,\n      //  and therefore not iterable. Consequently, trying to use ...previousComments in the return.\n      //  was breaking the code.\n      //\n      //  The solution is to set previousComments to an empty array when it is initially undefined:\n      //\n      //////////////////////////////////////////////////////////////////////////\n\n\n      // let previousComments = state.comments[action.payload.id];\n      //\n      // if (previousComments === undefined) {\n      //   previousComments = [];\n      // }\n      //\n      // return {\n      //   ...state,\n      //   comments: {\n      //     ...state.comments, [action.payload.id] : [...previousComments, action.payload.comment]\n      //   }\n      // };\n\n\n\n    case LOAD_COMMENTS:\n      //the action.payload should have a structure in which it is an object.\n      //That object having various numbers as properties, and each of those keys/properties\n      //has a value of an array of strings.\n      //1570497435602: [\"I love this building\", \"It's so dusty\"]\n\n      return {\n        ...state,\n        comments: action.payload\n      };\n\n    default:\n      return state;\n  }\n}\n","//Note in the tutorial he actually named the parent directory: 'redux'\n\nimport { combineReducers } from \"redux\";\nimport photoReducer        from \"./photoReducer\";\nimport commentReducer      from \"./commentReducer\";\n\n\n//We will create a reducer for every distinct piece of state.\n//That reducer will be in charge of updating that piece of state.\n//Since I am prepending export default, but you can also do:\n//\n//  const rootReducer = combineReducers(...)\n//  export default rootReducer;\n//\n//\n//Rather I give it the name of rootReducer on import.\n//However, you could do it the other way around.\n\nexport default combineReducers({\n  photoReducer:   photoReducer,\n  commentReducer: commentReducer\n});\n","//Used both by ____Actions.js and by ____Reducer.js\n\nexport const DELETE_PHOTO   = \"DELETE_PHOTO\";\nexport const ADD_PHOTO      = \"ADD_PHOTO\";\n\nexport const ADD_COMMENT    = \"ADD_COMMENT\";\n\nexport const LOAD_PHOTOS    = 'LOAD_PHOTOS';\nexport const LOAD_COMMENTS  = 'LOAD_COMMENTS';\n","\n//Add { applyMiddleware, compose } to the list if you want to use thunk from redux-thunk as well.*\nimport { createStore, applyMiddleware, compose } from \"redux\";\nimport thunk from \"redux-thunk\";\n\n//Here we are importing the rootReducer from \"./reducers/index.js\"\nimport rootReducer from \"./reducers\";\n\n\nconst initialState = {};\nconst middleware   = [thunk];\n\n\n//A basic store if you don't need middleware\n//const store = createStore(rootReducer, initialState);\n\n\n//As store that uses the redux dev tool.\n// const store = createStore(\n//   rootReducer,\n//   initialState,\n//   window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n// );\n\n\n//A store that uses several pieces of middleware\nconst store = createStore(\n  rootReducer,\n  initialState,\n  compose(\n    applyMiddleware(...middleware),\n    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n  )\n);\n\nexport default store;\n","import * as firebase from 'firebase';\n\n// Your web app's Firebase configuration\nvar firebaseConfig = {\n  apiKey: \"AIzaSyCCiheMWXi-iio38Tqg4oXGWTH3OSzv5DY\",\n  authDomain: \"photowall-38074.firebaseapp.com\",\n  databaseURL: \"https://photowall-38074.firebaseio.com\",\n  projectId: \"photowall-38074\",\n  storageBucket: \"\",\n  messagingSenderId: \"380688214458\",\n  appId: \"1:380688214458:web:926ae6b558ce60c86b1583\"\n};\n\nfirebase.initializeApp(firebaseConfig);\n\nconst database = firebase.database();\n\n\n//database is imported into the action reducer files (e.g., photoActions)\nexport { database };\n","////////////////////////////////////////////////////////////////////////////////\n//\n//  This file contains all of the photo action creators (i.e., functions)\n//  Action creators return actions, which are objects.\n//  The object always has an type property and almost always has a payload (i.e., data) property.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nimport { DELETE_PHOTO, ADD_PHOTO, LOAD_PHOTOS } from \"./types\";\nimport { database } from '../../database/config';\n\n\n\n/* ===============================\n loadPhotos , startLoadingPhotos\n=============================== */\n\n\nexport const loadPhotos = (photos) => {\n  return { type: LOAD_PHOTOS, payload: photos };\n};\n\nexport const startLoadingPhotos = () => (dispatch) => {\n  console.log(\"database\");\n  console.log(database);\n  return database\n    .ref('photos')\n    .once('value')\n    .then(\n      (snapshot) => {\n        let photos = [];\n        snapshot.forEach(\n          (childSnapshot) => { photos.push(childSnapshot.val()) }\n        );\n        dispatch(loadPhotos(photos));\n      }\n    )\n    .catch(\n      (error) => { console.log(error) }\n    );\n};\n\n\n/* ===============================\n   addPhoto , startAddingPhoto\n=============================== */\n\n\n\nexport const addPhoto = (photo) => {\n  return { type: ADD_PHOTO, payload: photo };\n};\n\n\nexport const startAddingPhoto = (photo) => (dispatch) => {\n  return  database\n            .ref('photos')\n            .update({[photo.id] : photo})\n            .then(\n              () => { dispatch(addPhoto(photo)) }\n            )\n            .catch(\n              (error) => { console.log(error) }\n            );\n};\n\n\n/* ===============================\n deletePhoto , startDeletingPhoto\n=============================== */\n\n\n//The tutorial used the index, and not the id.\n//But that's kind of dopey in my opinion.\n//Note this will be imported into...\n//Then we use this.props.dispatch(deletePhoto) to send it to the reducer.\nexport const deletePhoto = (id) => {\n  return { type: DELETE_PHOTO, payload: id };\n};\n\n\nexport const startDeletingPhoto = (id) => (dispatch) => {\n  return  database\n            .ref(`photos/${id}`)\n            .remove()\n            .then(\n              () => {\n                dispatch(deletePhoto(id))\n              }\n            )\n            .catch(\n              (error) => { console.log(error) }\n            );\n};\n","import { ADD_COMMENT, LOAD_COMMENTS } from \"./types\";\nimport { database }    from '../../database/config';\n\n\n/* ===============================\n loadComments , startLoadingComments\n=============================== */\n\n\nexport const loadComments = (comments) => {\n  return { type: LOAD_COMMENTS, payload: comments };\n};\n\n\n\nexport const startLoadingComments = () => (dispatch) => {\n  //console.log(\"startLoadingComments() called.\")\n  return database\n    .ref('comments')\n    .once('value')\n    .then(\n      (snapshot) => {\n        //When we loaded photos we made: let photos = [];\n        //However, here we will be adding them to an object.\n        let comments = {};\n        snapshot.forEach(\n          (childSnapshot) => {\n            comments[childSnapshot.key] = Object.values(childSnapshot.val())\n          }\n        );\n        dispatch(loadComments(comments));\n      }\n    )\n    .catch(\n      (error) => { console.log(error) }\n    );\n};\n\n\n\n\n\n/* ===============================\n\n=============================== */\n\n\nexport const addComment = (comment, id) => {\n  return {\n    type: ADD_COMMENT,\n    payload: {\n      id: id,\n      comment: comment\n    }\n  };\n};\n\nexport const startAddingComment = (comment, id) => (dispatch) => {\n  return  database\n            .ref(`comments/${id}`) //or .ref('comments/+id')\n\n            ////////////////////////////////////////////////////////////////////\n            //\n            //  push() will append our comment within/under the node such that\n            //  the comment will have a key of some firebase auto-generated unique id.\n            //  If you don't give each comment a unique id with push(), then they will\n            //  end up overwriting themselves in the database.\n            //\n            //  Note: Addphoto.js is still using id: Number(new Date()) for the id,\n            //  As far as I know, the comment also uses this id, so why employ an\n            //  auto-generated unique id?\n            //  Why use push()?\n            //  Why not just use update()\n            //\n            //  So what actually happens in firebase is that the properties of the comments\n            //  object are assigned an id corresponding to the id of the photo.\n            //  (e.g., the timestamp converted to a number).\n            //  However, the associated value no longer holds an array (at least not in the firebase.\n            //  Instead, it contains a series of sub-nodes.\n            //  And it is those sub-nodes that require a unique identifier:\n            //\n            //    comments\n            //      15705535780\n            //        LqgUYEcvksgCkKmrxq7\n            //        LqgU_gq6IfVjHBI3waD\n            //\n            //\n            ////////////////////////////////////////////////////////////////////\n\n            .push(comment)\n            .then(\n              () => { dispatch(addComment(comment, id)) }\n            )\n            .catch(\n              (error) => { console.log(error) }\n            );\n};\n","import React     from 'react';\nimport PropTypes from 'prop-types';\nimport  { Link } from 'react-router-dom';\n\n\nfunction Photo(props) {\n  const { photo, startDeletingPhoto } = props;\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  //  When we delete the photo from within Single.js\n  //  We get: TypeError: Cannot read property 'id' of undefined.\n  //  This is because the id it's looking for has been deleted.\n  //  To get around this, we add props.history.push('/') to\n  //  the Remove button's onClick.\n  //\n  //  -\n  //\n  //  Note: When Photo is implemented from within Single it still has this <Link />\n  //  wrapper around the image. However, clicking on it won't do anything\n  //  because we're already on that page. Fortunately, it doesn't even refresh the page.\n  //\n  //  Ideally, it would be nice to conditionally render the <img> with or without the <Link/>\n  //  wrapper depending on what parent implemented it.\n  //\n  //  In order to implement this idea, we can pass a prop from Single to\n  //  Photo: <Photo isSingle={true} />, then do this in the return below:\n  //\n  //    { !isSingle && <img className=\"photo\" src={photo.imageLink} alt={photo.description} /> }\n  //    { isSingle  && (\n  //      <Link to={`/single/${photo.id}`}>\n  //        <img className=\"photo\" src={photo.imageLink} alt={photo.description} />\n  //      </Link>\n  //      )\n  //    }\n  //\n  //  However, for now I will leave it as it is.\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n\n  //When specifying url fragments, be sure to prepend the beginning backslash: `/single/${photo.id}`\n  return (\n    <figure className=\"figure\">\n      <Link\n        to={`/single/${photo.id}`}\n      >\n        <img className=\"photo\" src={photo.imageLink} alt={photo.description} />\n      </Link>\n\n\n      <figcaption>\n        {photo.description}\n      </figcaption>\n\n      <div className=\"button-container\">\n        <button\n          className=\"button\"\n          onClick={\n            () => {\n              startDeletingPhoto(photo.id);\n\n              //Additional feature to be implemented later.\n              //startDeletingComment(photo.id)\n\n\n              //When Photo is rendered from withing Single.js, and we remove the photo,\n              //it causes a crash. The solution is to call props.history.push(\"/\");\n              //To redirect to the Home page.\n              //\n              //However, when Photo is rendered initially from within Photowall,\n              //this can create problems becuase props.history doesn't exist.\n              //\n              //For some reason this was not an issue in the tutorial.\n              //However, it makes sense that it is.\n              //Initially, there is no props.history.\n              //Consequently, when we first try to remove a photo from the Photowall,\n              //we would get an error.\n              //I think the tutorial didn't do this at all.\n              if (props.history) { props.history.push(\"/\"); }\n\n              //The application will now take us back to the Photowall / Home page.\n              //However, if we were to then click on the back button in the browser\n              //it would break the application: TypeError: Cannot read property 'id' of undefined\n              //Thus in Single.js we do this:\n\n            }\n          }\n        > Remove </button>\n\n        <Link className=\"button\" to={`/single/${photo.id}`}>\n          <div className=\"comment-count\">\n            <div className=\"speech-bubble\"></div>\n            {props.comments[photo.id] ? props.comments[photo.id].length : 0}\n          </div>\n        </Link>\n      </div>\n    </figure>\n  );\n}\n\n\nPhoto.propTypes = {\n  photo: PropTypes.object.isRequired\n};\n\nexport default Photo;\n","import React     from 'react';\nimport PropTypes from 'prop-types';\nimport { Link }  from 'react-router-dom';\nimport Photo     from './Photo';\n\n\nfunction Photowall(props) {\n\n  return (\n    <React.Fragment>\n      <Link className=\"plus-button\" to=\"/addphoto\"></Link>\n      <div className=\"photo-container\">\n        {\n          //Before mapping over the photos array, we will first sort it according to the id property\n          //The id property is set to a value representing a unix timestamp converted to a number.\n          //Consequently, more recent photos are represented by larger numbers.\n\n          props.photos\n            .sort(function(x,y){\n              //sort in descending order.\n              return y.id - x.id;\n            })\n            .map(\n              (photo, index) => {\n                return ( <Photo key={index} photo={photo} {...props} /> );\n              }\n          )\n        }\n      </div>\n    </React.Fragment>\n  );\n}\n\nPhotowall.propTypes = {\n  photos: PropTypes.array.isRequired\n};\n\nexport default Photowall;\n"," import React, { Component }    from 'react';\n//import PropTypes from 'prop-types';\n\n\nclass Addphoto extends Component {\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  //  Note:\n  //  Ordinarily, I might create a:\n  //\n  //    onChange = e => this.setState({ [e.target.name]: e.target.value });\n  //\n  //\n  //  This would correspond to state properties matching the name attributes in the input elements.\n  //  Moreover, each input would have onChange={this.onChange}\n  //  However the tutorial did not do it this way.\n  //  Instead it did this:\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n\n  handleSubmit = (e) => {\n    e.preventDefault();\n    const description = e.target.elements.description.value;\n    const imageLink   = e.target.elements.link.value;\n\n    //The value of the id property is a unix time stamp converted to a number (e.g., 1570312242552).\n    //This will allow us to order the images by number (larger numbers representing more recently added images).\n    const data        = { id: Number(new Date()), description, imageLink };\n    console.log(data);\n\n    if (imageLink && description){\n      this.props.startAddingPhoto(data);\n      this.props.history.push('/');\n    }\n  }\n\n  //Test the form:\n  //first input: https://images.pexels.com/photos/459225/pexels-photo-459225.jpeg\n  //description: Pretty mountains!\n  render(){\n    return (\n      <React.Fragment>\n\n\n        <div className=\"addphoto-form-container\">\n          <form onSubmit={this.handleSubmit}>\n            <input type=\"text\" name=\"link\"        placeholder=\"Image link...\"/>\n            <input type=\"text\" name=\"description\" placeholder=\"Description...\"/>\n            <button className=\"form-button\">Submit</button>\n          </form>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\n\n//Photo.propTypes = {};\n\nexport default Addphoto;\n","import React, { Component } from 'react';\n\n\nclass Comments extends Component {\n\n  handleSubmit = (e) => {\n    e.preventDefault();\n\n    const comment = e.target.elements.comment.value;\n\n    ////////////////////////////////////////////////////////////////////////////\n    //\n    //  Note: anytime an action creator emits an action it goes to every single reducer.\n    //  This is normal behavior.\n    //  Thus if we put these in the photoReducer and the commentReducer, respectively:\n    //\n    //     console.log(\"photoReducer called with action: \" , action);\n    //     console.log(\"commentReducer called with action: \" , action);\n    //\n    //\n    //  They would both get invoked.\n    //  However, only commentReducer has a switch that evaluates ADD_COMMENT.\n    //  Thus, when photoReducer gets the action, it merely defaults to returning state the state\n    //  of photos (unchanged).\n    //\n    //  The important takeaway here is that each reducer should handle distinct action types.\n    //  If for some reason they share an action type, you should make sure that's what you intended.\n    //\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    this.props.startAddingComment(comment, this.props.id);\n\n    //Clear the form;\n    e.target.elements.comment.value = '';\n  }\n\n\n  render() {\n    return (\n      <div className=\"comment\">\n        {\n          this.props.photoSpecificComments.map(\n            (comment, index) => {\n              return <p key={index}> {comment} </p>;\n            }\n          )\n        }\n\n        <form className=\"comment-form\" onSubmit={this.handleSubmit }>\n          <input type=\"text\" placeholder=\"Comment on image...\" name=\"comment\" />\n          <input type=\"submit\" hidden/>\n        </form>\n      </div>\n    );\n  }\n}\n\n\nexport default Comments;\n","import React, { Component } from 'react';\nimport Photo                from './Photo';\nimport Comments             from './Comments';\n\n\n//This can be converted to a function component.\nclass Single extends Component {\n\n  render(){\n\n    ////////////////////////////////////////////////////////////////////////////\n    //\n    //  console.log(this.props.match);\n    //  Logs something like the following:\n    //\n    //     {\n    //       isExact: true,\n    //       params:  {id: \"2\"},\n    //       path:    \"/single/:id\",\n    //       url:     \"/single/2\"\n    //     }\n    //\n    //  Thus what are after is this.props.match.params.id\n    //  With that id, we can get the corresponding state.photos array element\n    //\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    const { match, photos, comments, loading } = this.props;\n    const id               = Number(match.params.id);\n    const photo            = photos.find((photo) => photo.id === id);\n\n\n\n\n    //Initially, specificComments will be undefined (i.e., when Single.js renders a photo without comments).\n    //This would break the code when we try to map over it in Comments.js\n    //For this reason, instead of merely doing this:\n    //const photoSpecificComments = this.props.comments[id];\n    //We do this:\n    const photoSpecificComments = comments[id] || [];\n\n\n    if (loading === true){\n      return <div className=\"loader\">Loading...</div>;\n    } else if (photo) {\n      return (\n        <main>\n          <div className=\"single-photo-container\">\n            <Photo photo={photo} {...this.props} />\n\n            <Comments\n              startAddingComment={this.props.startAddingComment}\n              photoSpecificComments={photoSpecificComments}\n              id={id}\n            />\n          </div>\n        </main>\n      );\n    } else {\n      return <h2 className=\"no-photo-found\">...no photo found.</h2>\n    }\n  }\n}\n\nexport default Single;\n","import React, { Component }   from 'react';\nimport { Route, Link }        from 'react-router-dom';\n\nimport * as photoActions      from './store/actions/photoActions'; //import { deletePhoto, addPhoto } from './store/actions/photoActions';\nimport * as commentActions    from './store/actions/commentActions';\nimport { bindActionCreators } from 'redux';\n\n\n////////////////////////////////////////////////////////////////////////////////\n//\n//\n//  The tutorial suggested that the standard practice is to pass the store\n//  to the highest level component (i.e., App.js).\n//  From there we would then pass the data down as props.\n//  Thus data should GENERALLY go from the top down.\n//  So far that doesn't really solve anything.\n//  Thus there is a caveat: IF you need the data in a DEEPLY NESTED subcomponent.\n//  In that case, we will inject the data directly into the subcomponent.\n//  The idea here is that we don't want to be adding connect() to every single component everywhere.\n//  Doing that would make the data flow more difficult to trace.\n//\n//  That said, if the component is sufficiently nested, we can connect the store dircectly\n//  to that component.\n//  This app is fairly simple, and we don't really need to inject the store in a deeply\n//  nested subcomponent.\n//  Suppose, however, that the Photo component was deeply nested.\n//  We could connect it the Redux store like in the exact same way that we've connected\n//  App.js (at the bottom of this file):\n//\n//    import { connect } from \"react-redux\";\n//\n//    ...\n//\n//    function mapStateToProps(state){\n//      return { photos: state.photoReducer.photos };\n//    }\n//\n//    export default connect(mapStateToProps, null)(Photo);\n//\n//\n//  Redux was not made primarily to directly inject store (state) into every other component.\n//  It was made so that managing the state of the application could be more predictable\n//  through the use of pure functons (i.e. reducers).\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n\nimport { connect } from \"react-redux\";\nimport Photowall   from './components/Photowall';\nimport Addphoto    from './components/Addphoto';\nimport Single      from './components/Single';\n\n\nclass App extends Component {\n  state = {\n    //When the App first starts we are, indeed, loading our photos.\n    //This gets passed to <Single /> below.\n    loading: true\n  };\n\n  componentDidMount(){\n    //Calls to firebase.\n\n\n    //Presumably, the .then() works in this instance because startLoadingPhotos()\n    //uses firebase which creates a Promise.\n    this.props.startLoadingPhotos()\n      .then(\n        () => {\n          //setTimeout is used merely to extend the loading demonstration.\n          //setTimeout(() => {\n            this.setState({ loading: false })\n          //}, 1000);\n        }\n      )\n\n    this.props.startLoadingComments();\n\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  //  Below, the render prop is used in our <Route /> components (instead of component={...}).\n  //  In the first case, it is used for the purposes of rendering multiple elements/components.\n  //  In the second case, it is used in order to pass props.\n  //\n  //  Below, the history prop is used to take us back the previous page.\n  //\n  ////////////////////////////////////////////////////////////////////////////////\n  render(){\n    return (\n      <React.Fragment>\n        <header>\n          <h1>\n            <Link to=\"/\">Photowall></Link>\n          </h1>\n        </header>\n\n\n\n        <Route\n          exact\n          path=\"/\"\n          render={\n            () => {\n              return (\n                <div>\n\n\n                  {/* ...this.props passes down all props that exist in App\n                  It's equivalent to writing:\n                  photos: props.photos\n                  deletePhoto: props.deletePhoto\n                  etc.\n                  */}\n                  <Photowall { ...this.props } />\n                </div>\n              );\n            }\n          }\n        />\n\n      {/* In the tutorial there was a discussion in the \"Actions (2) - Adding Posts\"\n      video that said that react-router and redux generally work fine.\n      However, when connecting a component to a redux store with connect(), the component\n      stops updating the location change.\n      Consequently, clicking on the + symbol link will change the URL to http://localhost:3000/addphoto,\n      but it wouldn't actually change the page.\n      A fix was mad fore this by using:\n\n         import { withRouter } from 'react-router';\n\n\n      Then do this to const App = connect(mapStateToProps, mapDispatchToProps)(Main); :\n\n         const App withRouter(connect(mapStateToProps, mapDispatchToProps)(Main));\n\n\n      Note: I did not need to do this because I did not implement my project in the same\n      way as the tutorial did. In other words, I don't have a <Main/> component.\n      I just used App directly. This may be why I don't run into this issue.\n      It could also be because I'm using react-router v5.\n       */}\n\n       {/*\n         Below we could've written (same difference):\n         (params) => ( <Addphoto {...this.props} history={params.history} /> )\n       */}\n        <Route\n          path=\"/addphoto\"\n\n\n\n          render={\n            ( {history} ) => {\n              return (\n                <Addphoto {...this.props} history={history} />\n              );\n            }\n          }\n        />\n\n      {/* When clicking on a photo <Link /> Photo.js is set up such that the url will be:\n\n          `/single/${photo.id}`\n\n      Whatever the specific value of photo.id is, it is accessible to us here through params:\n      Below we are passing params and then destructuring (i.e., spreading) each one into a property,\n      such that the name of each prop will correspond the the name of each property from params.\n      params will include several things (e.g., history, match, etc.)\n      */}\n\n\n\n      {/* PLACE {...this.props} BEFORE {...params} :\n\n      In the tutorial it seemed to have mattered that ...this.props came first.\n      The reasong being that the App component's this.props also has a match object.\n      By passing in all {...this.props} after {...params} (i.e., the wrong way),\n      the match object from {...params} is overriden by the match object in {...this.props}.\n\n      That said, I never had any problems either way.\n      */}\n        <Route\n          path=\"/single/:id\"\n          render={\n            (params) => {\n              return (\n                <Single loading={this.state.loading} {...this.props} {...params} />\n              );\n            }\n          }\n        />\n      </React.Fragment>\n    );\n  }\n}\n\n//This will allow us to access photos as: this.props.photos and comments as this.props.comments\nfunction mapStateToProps(state){\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  //  Note: the tutorial set the various state's to arrays in each respective reducer.\n  //  And he named the reducers photos and comments\n  //  In such a case, our mapStateToProps would look like this:\n  //\n  //    return {\n  //      posts:    state.photos,    //If there is only one piece of state, you can just reference state (i.e., not state.photos)\n  //      comments: state.comments\n  //     }\n  //\n  //\n  //  However, because I used ojects, my return statement looks different.\n  //  It has another dot.\n  //  Moreover, rather than naming the reducers photos and comments,\n  //  I named them photoReducer and commentReducer.\n  //  Then I named set state to an object that had a photos and comments property, respectively.\n  //\n  //  Both approaches work.\n  //  And both have advantages and disadvantages.\n  //  I like the way I've done it because it's more clear, more specific, and using objects is more flexible.\n  //\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n\n  return {\n    photos:   state.photoReducer.photos,\n    comments: state.commentReducer.comments\n  };\n}\n\n//mapDispatchToProps is normally used to provide a shorthand inside of our\n//component such that instead of writing this.props.dispatch(deletePhoto(...)), we can just\n//write this.props.deletePhoto(...)\nfunction mapDispatchToProps(dispatch){\n\n  //return bindActionCreators({deletePhoto, addPhoto }, dispatch);\n  return bindActionCreators({...photoActions, ...commentActions}, dispatch);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//\n//  (App) is the component that is receiving the data from the store.\n//  connect() doesn't modify the component that is passed in to it.\n//  Instead, it's returning a new connected component (i.e., connected to the Redux store).\n//  For example in the Codepen examples I would do this:\n//\n//    const AppContainer = connect(mapStateToProps, null)(App);\n//\n//\n//  However, in this case I am eliminating the need to name it.\n//  Instead I am merely exporting it directly (to index.js).\n//  Then in index.js we name it App: import App from './App';\n//  But what is actually being rendered now is:\n//\n//   <Connect(App)>...</Connect(App)>\n//\n////////////////////////////////////////////////////////////////////////////////\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","import React                    from 'react';\nimport ReactDOM                 from 'react-dom';\nimport { HashRouter } from 'react-router-dom';\n\n\n//Note: Brad typically imports this into App.js and wraps it\n//around the content in the return statement of the App component.\nimport { Provider }      from 'react-redux';\nimport store             from './store/store';\nimport App               from './App';\nimport './styles/style.css';\n\n\n//The actual tutorial renders <Main />\n//I render <App />, and <App/> returns <Main />\nReactDOM.render(\n  <Provider store={store}>\n    <HashRouter><App /></HashRouter>\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}